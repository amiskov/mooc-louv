# Basic programming concepts

## Functional programming
Самая простая парадигма, основа для других, форма декларативного программирования.

### Декларативное программирование

#### Long term view
Описываем, что хотим в результате, а не то, как это нужно делать.

**Если императивное — это команды (commands), то декларативное, это свойства результата (properties).**

Исторически вся информатика стремится к декларативности.

#### Short term view
Декларативный подход использует математические концепции: функции, отношения (relations, реляционное исчисление).

**Императивное основано на изменении состояния (stateful), декларативное его не изменяет (stateless).**

Functional programs do not have any internal memory, they are stateless.

_Confluency, конфлюэнтность_ — свойство единственности окончания. Обеспечение однозначности вычислений множеством функций, исполняемых в произвольном порядке. ...which means that if you have a large program built out of functions that are composed together, we can evaluate in any order and get the same result.

_Referential transparency, чистота ЯП_ — отсутствие побочных эффектов, детерминированность (чистые функции).

Функциональные языки: Lisp, Scheme, Haskwll, ...
Логические языки (реляционные): SQL, Prolog, ...
Комбинации: XSL (форматирование), XSLT (трансформирование)

Это программирование без изменения состояния (without state). Нельзя изменять значение структур данных, нет переменных, только константы.

### Основные преимущества
Стабильность. Функции не меняются. Все действия происходят не в самих функциях, а в аргументах.

Т. к. состояние не меняется, то легко тестировать.

Stateless server — куки. Они хранятся на машине пользователя, а не на сервере.

### Single Assignment
Однажды присвоенное значение для идентификатора не может быть изменено. По факту можно присваивать значение, но только то же самое.

### Function Composition
Когда в одной функции используется другая. Позволяет делать слоеные системы. Первый шаг к абстракции данных.

```
declare
fun {SlowComputation X Y}
   {Delay 1000}
   X + Y
    % Do something
end

{Browse
 local X in
    X = {SlowComputation 1000 1}
    X + X + X
 end
}
```

### Рекурсия
Возможность ф-и вызывать саму себя. Тут нужно условие:

```oz
declare
fun {SumDigitsR N}
   if (N == 0) then 0
   else
      (N mod 10) + {SumDigitsR (N div 10)}
   end
end

{Browse {SumDigitsR 1234}}
```

### Полнота по Тьюрингу
Язык, в котором можно производить математические вычисления, создавать ф-и, из одной ф-и вызывать другую и реализовать рекурсию называется тьюринг-полным. То есть он умеет делать то, что делает машина Тьюринга.

