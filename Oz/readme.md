# Синтаксис Oz

```oz
declare
X = 42 % определяем на уровне программы
% X = 3 % ошибка, нельзя переопределять идентификатор
{Browse X}

declare
X = 3 % нормально, идет переопределение с помощью `declare`
{Browse X}

% вариация `declare`,
% ограничиваем область видимости (определяем scope) `X`: от `local` до `end`
local X in
   X = 32
   {Browse X}
end

{Browse X} % 3
```

`declare` и `local` — одной природы. Только `local` ограничивает область видимости.

`local` позволяет распознать ограничение области видимости в тексте программы. Это называется `lexical scoping` или `static scoping` (лексическое или статическое окружение).

`local` определяет составную инструкцию (compound instruction).

## Mozzart
Запуск процедуры/функции:

```oz
{Browse 11*11}
```

`Browse` — имя процедуры (открывает окно Oz-браузера).

```oz
declare
X=12*34
{Browse X}
```

Тут `X` — это идентификатор, который ссылается на переменную, которую на самом деле не видно и она содержит значение `12*34`. Всегда начинается с Прописной. С прописной потому, что под идентификаторами скрываются символьные константы, которые пишутся с маленькой буквы. И значение идентификаторов вызываются через функцию окружения: `E(X)=>x`.

### Математика
#### Numbers
*Exact numbers* — integers

*Approximate numbers* — floating point

Нет автоматической конвертации. Нужно использовать `IntToFloat` и `FloatToInt`. Работает принцип, что нельзя смешивать разные концепты представления данных: точные числа (integers) и приблизительные (плавающая точка, которые компьютер представляет с некоторыми погрешностями).

#### Operations
`/` — float division
`div` — integer division (отсекает плавающую точку)
`mod` — остаток от деления

### Functions
Определение функции:

```
declare
fun {Sqr X}
    X * X
end

{Browse {Sqr 10}}

declare
fun {SumDigits N}
    (N mod 10) + (N div 10) mod 10 + (N div 100) mod 10
end

{Browse {SumDigits 999}}
```

### Lists

```oz
declare
L = [1 2 3]
M = {Append L L}
N = nil % пустой список
```